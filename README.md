# 동시성 제어 방식에 대한 분석

## 동시성 문제

동시성 문제는 여러 프로세스나 스레드가 동시에 실행될 때 데이터의 일관성이 깨지거나 예기치 못한 결과가 발생하는 문제입니다. 여러 작업이 동시에 수행되면 예상치 못한 순서로 처리되거나, 한 작업이 데이터를 수정하는 동안 다른 작업이 그 데이터를 참조하거나 수정하려고 할 때 문제가 발생할 수 있습니다.

## 동시성 제어 방식

### 1. Application Level

**개념**: 애플리케이션 코드 내에서 동시성 문제를 해결하는 방법입니다. 여러 스레드가 공유하는 리소스를 접근할 때 애플리케이션에서 명시적으로 제어합니다.  
**특징**: 애플리케이션 코드에 직접 구현되므로 유연하게 설정할 수 있지만, 구현이 복잡할 수 있습니다.

### 2. Database Lock

**개념**: 데이터베이스에서 제공하는 락을 이용하여 특정 데이터를 수정하거나 조회할 때 다른 작업이 이를 동시에 처리하지 못하도록 제어합니다.  
**특징**: 데이터베이스에서 자동으로 처리되므로 일관성이 보장됩니다. 그러나 락을 잘못 사용할 경우 성능 저하나 교착 상태(Deadlock)가 발생할 수 있습니다.

### 3. Redis

**개념**: Redis와 같은 인메모리 데이터베이스를 이용하여 동시성 문제를 해결하는 방법입니다. Redis는 빠르고 효율적인 분산 락을 제공하여 여러 시스템 간 동기화 문제를 해결할 수 있습니다.  
**특징**: 빠르고 효율적이며 분산 시스템에서 유용합니다.

---

## 애플리케이션 레벨에서 동시성 제어 방법
* 해당 프로젝트는 멀티 스레드 환경에서 여러 스레드가 동일한 데이터를 처리할 때 발생하는 문제 상황을 가정하고 애플리케이션 레벨에서 접근합니다.

### 동기화(Synchronization)
- 여러 스레드가 동시에 같은 데이터를 수정하지 못하도록 synchronized 키워드를 사용하여 메서드나 블록을 동기화합니다.
- 그러나 동기화는 전체 성능 저하를 초래할 수 있으며, 다수의 스레드가 동기화된 자원을 기다리게 되어 병목현상이 발생할 수 있습니다.

### 세마포어(Semaphore)
- 제한된 수의 스레드만 리소스에 접근하도록 제어합니다.
- 자원 제한 수를 설정하기는 유용하지만, 복잡한 동작을 구현하기에는 어려움이 있을 수 있습니다.

### 락(Lock)
- 특정 자원에 대한 접근을 제어하며, 한 스레드가 자원을 사용하는 동안 다른 스레드는 대기하게 됩니다.
- 락을 잘못 관리하면 데드락(Deadlock)과 같은 문제를 초래할 가능성이 있습니다.

---

## 선택한 방식: ConcurrentHashMap + ReentrantLock

### ConcurrentHashMap

ConcurrentHashMap은 멀티스레드 환경에서 안전하게 데이터를 저장할 수 있는 해시맵입니다.
- **특징**: 여러 스레드가 동시에 접근하더라도 각 스레드가 별도의 슬롯에 접근하므로 성능 저하 없이 작업을 처리할 수 있습니다.
- 데이터의 일관성을 유지하면서도 높은 성능을 제공합니다.

### ReentrantLock

ReentrantLock은 특정 코드 블록을 한 번에 하나의 스레드만 실행하도록 보장합니다.
- **특징**: 락 해제 시점을 명확히 지정하거나 특정 조건에서 락을 세밀하게 제어할 수 있는 유연성을 제공합니다.
- 재진입 가능(같은 스레드가 여러 번 락을 획득 가능)하여 안전성과 유연성을 동시에 확보할 수 있습니다.

---

## ConcurrentHashMap + ReentrantLock 조합을 선택한 이유

1. **성능 최적화**
    - ConcurrentHashMap은 기본적으로 여러 스레드가 동시에 데이터를 다룰 수 있게 설계되어 있어서 멀티스레드 환경에서 높은 성능을 보장합니다.
    - 데이터의 일관성을 유지하면서도 불필요한 동기화 비용을 최소화할 수 있습니다.

2. **정교한 제어**
    - ReentrantLock은 단순한 synchronized보다 더 유연하게 락을 걸고 해제할 수 있어 불필요한 기다림을 줄일 수 있습니다.  
      예를 들어, 언제 락을 해제할 지, 특정 조건에서만 락을 걸고 싶을 때 유용합니다.

3. **안전성과 유연성**
    - ConcurrentHashMap만으로 복잡한 동시성 문제를 해결할 수 없을 때, ReentrantLock을 활용하여 특정 코드 블록의 실행을 보다 안전하게 제어할 수 있습니다.
    - 필요한 경우 특정 데이터 접근에 대해 명시적으로 락을 설정함으로써 안정성과 예측 가능성을 높일 수 있습니다.


---

## 결론

ConcurrentHashMap과 ReentrantLock의 조합은 성능과 안전성을 확보하면서도 본 프로젝트의 요구사항에 부합하는 적절한 솔루션이었습니다.
- **ConcurrentHashMap**: 세분화된 락 구조를 통해 높은 성능을 보장합니다.
- **ReentrantLock**: 정교하고 유연한 제어를 가능하게 합니다.

이 조합은 멀티스레드 환경에서 데이터의 일관성을 유지하면서도 성능 저하를 최소화할 수 있는 효과적인 방식 중 하나입니다.
